{"version":"0.3.0","body":"// Author: Farid Javadnejad\n// Institution: WSP Geomatics USA, Inc.\n// Date: 2025-06-26\n// \n// DESCRIPTION:\n// This Office Script computes a 2D affine transformation using point coordinates stored in Excel.\n// It reads coordinate pairs from two worksheets: \"SOURCE\" and \"TARGET\", each containing corresponding X and Y values.\n// The script calculates the affine transformation coefficients and residuals, and writes the results to a \"REPORT\"\n//\n// USAGE:\n// - Ensure the \"SOURCE\" and \"TARGET\" sheets each contain at least 3 matching point pairs.\n// - Column B contains Y (Northing) and column C contains X (Easting) values, with one header row.\n// - Run the script to generate or update a \"REPORT\" sheet with the calculated affine coefficients and residual statistics.\n//\n// EXAMPLE:\n// SOURCE:\n// PID    Northing (Y)    Easting (X)\n// 1      488591.5266     644005.776\n// 2      489757.2155     650091.4286\n// 3      490392.2533     657073.5145\n//\n// TARGET:\n// PID    Northing (Y)    Easting (X)\n// 1      488507.6308     643999.1308\n// 2      489696.2621     650080.3439\n// 3      490357.6270     657059.9853\n// \n// REPORT:\n// Affine Transformation Coefficients\t\n// A0 = 1840.558052264190\n// A1 = 0.999992889093\n// A2 = -0.003771297120\n// B0 = -2509.155681609060\n// B1 = 0.003771297439\n// B2 = 0.999992882626\n//\n// DISCLAIMER:\n// This script was developed with the assistance of AI tools for coding, debugging, and validation.\n// ---------\n\nfunction main(workbook: ExcelScript.Workbook) {\n  const sourceSheet = workbook.getWorksheet(\"SOURCE\");\n  const targetSheet = workbook.getWorksheet(\"TARGET\");\n  let reportSheet = workbook.getWorksheet(\"REPORT\");\n\n  if (!reportSheet) {\n    reportSheet = workbook.addWorksheet(\"REPORT\");\n  } else {\n    reportSheet.getUsedRange()?.clear();\n  }\n\n  const sourceData = sourceSheet.getUsedRange()?.getValues() || [];\n  const targetData = targetSheet.getUsedRange()?.getValues() || [];\n\n  const srcCoords = sourceData.slice(1).filter(row => row[1] !== \"\" && row[2] !== \"\");\n  const tgtCoords = targetData.slice(1).filter(row => row[1] !== \"\" && row[2] !== \"\");\n  const n = srcCoords.length;\n\n  if (n < 3 || tgtCoords.length !== n) {\n    throw new Error(\"At least 3 matching point pairs are required.\");\n  }\n\n  const srcY = srcCoords.map(row => Number(row[1]));\n  const srcX = srcCoords.map(row => Number(row[2]));\n\n  const tgtY = tgtCoords.map(row => Number(row[1]));\n  const tgtX = tgtCoords.map(row => Number(row[2]));\n\n  const meanY = average(srcY);\n  const meanX = average(srcX);\n\n  // Centered coordinates\n  const A: number[][] = [];\n  for (let i = 0; i < n; i++) {\n    A.push([1, srcX[i] - meanX, srcY[i] - meanY]);\n  }\n\n  const At = transpose(A);\n  const AtA = multiply(At, A);\n  const Atbx = multiply(At, tgtX);\n  const Atby = multiply(At, tgtY);\n\n  const coeffsX = solve3x3(AtA, Atbx);\n  const coeffsY = solve3x3(AtA, Atby);\n\n  // Adjust intercepts\n  const A0 = coeffsX[0] - coeffsX[1] * meanX - coeffsX[2] * meanY;\n  const A1 = coeffsX[1]; // now X coefficient\n  const A2 = coeffsX[2]; // now Y coefficient\n\n  const B0 = coeffsY[0] - coeffsY[1] * meanX - coeffsY[2] * meanY;\n  const B1 = coeffsY[1];\n  const B2 = coeffsY[2];\n\n  const coeffs = [[\"A0\", A0], [\"A1\", A1], [\"A2\", A2], [\"B0\", B0], [\"B1\", B1], [\"B2\", B2]];\n  reportSheet.getRange(\"A1\").setValue(\"Affine Transformation Coefficients\");\n  reportSheet.getRange(\"A2:B7\").setValues(coeffs);\n\n  // === Residuals ===\n  const residualStart = 9;\n  reportSheet.getRange(`A${residualStart}`).setValue(\"Residuals\");\n  reportSheet.getRange(`A${residualStart + 1}:C${residualStart + 1}`).setValues([[\"Point #\", \"dX\", \"dY\"]]);\n\n  const residuals: (string | number)[][] = [];\n  const dxVals: number[] = [];\n  const dyVals: number[] = [];\n\n  for (let i = 0; i < n; i++) {\n    const estX = A0 + A1 * srcX[i] + A2 * srcY[i];\n    const estY = B0 + B1 * srcX[i] + B2 * srcY[i];\n    const dx = estX - tgtX[i];\n    const dy = estY - tgtY[i];\n    dxVals.push(dx);\n    dyVals.push(dy);\n    residuals.push([i + 1, dx, dy]);\n  }\n\n  reportSheet.getRange(`A${residualStart + 2}:C${residualStart + 1 + residuals.length}`).setValues(residuals);\n\n  const summaryStart = residualStart + 3 + residuals.length;\n  reportSheet.getRange(`A${summaryStart}:C${summaryStart + 2}`).setValues([\n    [\"Max\", Math.max(...dxVals.map(x => Math.abs(x))), Math.max(...dyVals.map(y => Math.abs(y)))],\n    [\"Avg\", average(dxVals.map(x => Math.abs(x))), average(dyVals.map(y => Math.abs(y)))],\n    [\"RMS\", rms(dxVals), rms(dyVals)]\n  ]);\n\n  reportSheet.getRange(`B2:C${summaryStart + 2}`).setNumberFormatLocal(\"0.000000000000\");\n\n  // === Helper Functions ===\n  function average(arr: number[]): number {\n    return arr.reduce((sum, val) => sum + val, 0) / arr.length;\n  }\n\n  function rms(arr: number[]): number {\n    return Math.sqrt(arr.reduce((sum, val) => sum + val * val, 0) / arr.length);\n  }\n\n  function transpose(m: number[][]): number[][] {\n    return m[0].map((_, i) => m.map(row => row[i]));\n  }\n\n  function multiply(a: number[][], b: number[] | number[][]): number[] | number[][] {\n    if (typeof (b[0]) === \"number\") {\n      return a.map(row => row.reduce((sum, val, j) => sum + val * (b as number[])[j], 0));\n    } else {\n      const bMat = b as number[][];\n      return a.map(row =>\n        bMat[0].map((_, j) =>\n          row.reduce((sum, val, k) => sum + val * bMat[k][j], 0)\n        )\n      );\n    }\n  }\n\n  function solve3x3(A: number[][], b: number[]): number[] {\n    const M = A.map((row, i) => [...row, b[i]]);\n    for (let i = 0; i < 3; i++) {\n      let maxRow = i;\n      for (let k = i + 1; k < 3; k++) {\n        if (Math.abs(M[k][i]) > Math.abs(M[maxRow][i])) maxRow = k;\n      }\n      [M[i], M[maxRow]] = [M[maxRow], M[i]];\n      const pivot = M[i][i];\n      for (let j = i; j <= 3; j++) M[i][j] /= pivot;\n      for (let k = 0; k < 3; k++) {\n        if (k !== i) {\n          const factor = M[k][i];\n          for (let j = i; j <= 3; j++) {\n            M[k][j] -= factor * M[i][j];\n          }\n        }\n      }\n    }\n    return M.map(row => row[3]);\n  }\n}\n","description":"","noCodeMetadata":"","parameterInfo":"{\"version\":1,\"originalParameterOrder\":[],\"parameterSchema\":{\"type\":\"object\",\"default\":{},\"x-ms-visibility\":\"internal\"},\"returnSchema\":{\"type\":\"object\",\"properties\":{}},\"signature\":{\"comment\":\"\",\"parameters\":[{\"name\":\"workbook\",\"comment\":\"\"}]}}","apiInfo":"{\"variant\":\"synchronous\",\"variantVersion\":2}"}